taichi.lang.ast.ast_transformer
===============================

.. py:module:: taichi.lang.ast.ast_transformer


Attributes
----------

.. autoapisummary::

   taichi.lang.ast.ast_transformer.build_stmt


Classes
-------

.. autoapisummary::

   taichi.lang.ast.ast_transformer.ASTTransformer


Functions
---------

.. autoapisummary::

   taichi.lang.ast.ast_transformer.reshape_list
   taichi.lang.ast.ast_transformer.boundary_type_cast_warning
   taichi.lang.ast.ast_transformer.build_stmts


Module Contents
---------------

.. py:function:: reshape_list(flat_list: list[Any], target_shape: Iterable[int]) -> list[Any]

.. py:function:: boundary_type_cast_warning(expression: taichi.lang.expr.Expr) -> None

.. py:class:: ASTTransformer

   Bases: :py:obj:`taichi.lang.ast.ast_transformer_utils.Builder`


   .. py:method:: build_Name(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Name)
      :staticmethod:



   .. py:method:: build_AnnAssign(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.AnnAssign)
      :staticmethod:



   .. py:method:: build_assign_annotated(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, target: ast.Name, value, is_static_assign: bool, annotation: Type)
      :staticmethod:


      Build an annotated assignment like this: target: annotation = value.

      :param ctx: The builder context.
      :type ctx: ast_builder_utils.BuilderContext
      :param target: A variable name. `target.id` holds the name as
      :type target: ast.Name
      :param a string.:
      :param annotation: A type we hope to assign to the target
      :param value: A node representing the value.
      :param is_static_assign: A boolean value indicating whether this is a static assignment



   .. py:method:: build_Assign(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Assign) -> None
      :staticmethod:



   .. py:method:: build_assign_unpack(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node_target: ast.Tuple, values, is_static_assign: bool)
      :staticmethod:


      Build the unpack assignments like this: (target1, target2) = (value1, value2).
      The function should be called only if the node target is a tuple.

      :param ctx: The builder context.
      :type ctx: ast_builder_utils.BuilderContext
      :param node_target: A list or tuple object. `node_target.elts` holds a
      :type node_target: ast.Tuple
      :param list of nodes representing the elements.:
      :param values: A node/list representing the values.
      :param is_static_assign: A boolean value indicating whether this is a static assignment



   .. py:method:: build_assign_basic(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, target: ast.Name, value, is_static_assign: bool)
      :staticmethod:


      Build basic assignment like this: target = value.

      :param ctx: The builder context.
      :type ctx: ast_builder_utils.BuilderContext
      :param target: A variable name. `target.id` holds the name as
      :type target: ast.Name
      :param a string.:
      :param value: A node representing the value.
      :param is_static_assign: A boolean value indicating whether this is a static assignment



   .. py:method:: build_NamedExpr(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.NamedExpr)
      :staticmethod:



   .. py:method:: is_tuple(node)
      :staticmethod:



   .. py:method:: build_Subscript(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Subscript)
      :staticmethod:



   .. py:method:: build_Slice(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Slice)
      :staticmethod:



   .. py:method:: build_ExtSlice(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.ExtSlice)
      :staticmethod:



   .. py:method:: build_Tuple(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Tuple)
      :staticmethod:



   .. py:method:: build_List(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.List)
      :staticmethod:



   .. py:method:: build_Dict(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Dict)
      :staticmethod:



   .. py:method:: process_listcomp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node, result) -> None
      :staticmethod:



   .. py:method:: process_dictcomp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node, result) -> None
      :staticmethod:



   .. py:method:: process_generators(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.GeneratorExp, now_comp, func, result)
      :staticmethod:



   .. py:method:: process_ifs(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.If, now_comp, now_if, func, result)
      :staticmethod:



   .. py:method:: build_ListComp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.ListComp)
      :staticmethod:



   .. py:method:: build_DictComp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.DictComp)
      :staticmethod:



   .. py:method:: build_Index(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Index)
      :staticmethod:



   .. py:method:: build_Constant(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Constant)
      :staticmethod:



   .. py:method:: build_Num(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Num)
      :staticmethod:



   .. py:method:: build_Str(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Str)
      :staticmethod:



   .. py:method:: build_Bytes(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Bytes)
      :staticmethod:



   .. py:method:: build_NameConstant(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.NameConstant)
      :staticmethod:



   .. py:method:: build_keyword(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.keyword)
      :staticmethod:



   .. py:method:: build_Starred(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Starred)
      :staticmethod:



   .. py:method:: build_FormattedValue(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.FormattedValue)
      :staticmethod:



   .. py:method:: build_JoinedStr(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.JoinedStr)
      :staticmethod:



   .. py:method:: build_call_if_is_builtin(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node, args, keywords)
      :staticmethod:



   .. py:method:: build_call_if_is_type(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node, args, keywords)
      :staticmethod:



   .. py:method:: is_external_func(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, func) -> bool
      :staticmethod:



   .. py:method:: warn_if_is_external_func(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node)
      :staticmethod:



   .. py:method:: canonicalize_formatted_string(raw_string: str, *raw_args: list, **raw_keywords: dict)
      :staticmethod:



   .. py:method:: build_Call(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Call)
      :staticmethod:



   .. py:method:: build_FunctionDef(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.FunctionDef)
      :staticmethod:



   .. py:method:: build_Return(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Return) -> None
      :staticmethod:



   .. py:method:: build_Module(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Module) -> None
      :staticmethod:



   .. py:method:: build_attribute_if_is_dynamic_snode_method(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node) -> bool
      :staticmethod:



   .. py:method:: build_Attribute(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Attribute)
      :staticmethod:



   .. py:method:: build_BinOp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.BinOp)
      :staticmethod:



   .. py:method:: build_AugAssign(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.AugAssign)
      :staticmethod:



   .. py:method:: build_UnaryOp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.UnaryOp)
      :staticmethod:



   .. py:method:: build_bool_op(op)
      :staticmethod:



   .. py:method:: build_static_and(operands)
      :staticmethod:



   .. py:method:: build_static_or(operands)
      :staticmethod:



   .. py:method:: build_BoolOp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.BoolOp)
      :staticmethod:



   .. py:method:: build_Compare(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Compare)
      :staticmethod:



   .. py:method:: get_decorator(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node) -> str
      :staticmethod:



   .. py:method:: get_for_loop_targets(node: ast.Name | ast.Tuple | Any) -> list
      :staticmethod:


      Returns the list of indices of the for loop |node|.
      See also: https://docs.python.org/3/library/ast.html#ast.For



   .. py:method:: build_static_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For, is_grouped: bool) -> None
      :staticmethod:



   .. py:method:: build_range_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_ndrange_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_grouped_ndrange_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_struct_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For, is_grouped: bool) -> None
      :staticmethod:



   .. py:method:: build_mesh_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_nested_mesh_for(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_For(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.For) -> None
      :staticmethod:



   .. py:method:: build_While(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.While) -> None
      :staticmethod:



   .. py:method:: build_If(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.If) -> ast.If | None
      :staticmethod:



   .. py:method:: build_Expr(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Expr) -> None
      :staticmethod:



   .. py:method:: build_IfExp(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.IfExp)
      :staticmethod:



   .. py:method:: ti_format_list_to_assert_msg(raw) -> tuple[str, list]
      :staticmethod:



   .. py:method:: build_Assert(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Assert) -> None
      :staticmethod:



   .. py:method:: build_Break(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Break) -> None
      :staticmethod:



   .. py:method:: build_Continue(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Continue) -> None
      :staticmethod:



   .. py:method:: build_Pass(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, node: ast.Pass) -> None
      :staticmethod:



.. py:data:: build_stmt

.. py:function:: build_stmts(ctx: taichi.lang.ast.ast_transformer_utils.ASTTransformerContext, stmts: list)

