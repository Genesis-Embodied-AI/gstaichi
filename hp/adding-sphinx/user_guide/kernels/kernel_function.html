
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Kernels and Functions &#8212; Taichi 1.8.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=b51e6972"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'user_guide/kernels/kernel_function';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Synchronization between Kernels and Python Scope" href="kernel_sync.html" />
    <link rel="prev" title="Spatially Sparse Data Structures" href="../basic/sparse.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.8.0" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Taichi 1.8.0 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../autoapi/index.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../autoapi/index.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../get-started/hello_world.html">Hello, World!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get-started/accelerate_python.html">Accelerate Python with Taichi</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get-started/accelerate_pytorch.html">Accelerate PyTorch with Taichi</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Basic</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../basic/field.html">Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/ndarray.html">Taichi Ndarray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/layout.html">Fields (advanced)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/offset.html">Coordinate Offsets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/external.html">Interacting with External Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/sparse.html">Spatially Sparse Data Structures</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Kernels</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Kernels and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_sync.html">Synchronization between Kernels and Python Scope</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Math</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../math/linear_solver.html">Linear Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/math_module.html">Math Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/sparse_matrix.html">Sparse Matrix</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Performance Tuning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../performance_tuning/performance.html">Performance Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance_tuning/profiler.html">Profiler</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Advanced</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../advanced/data_oriented_class.html">Data-Oriented Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/dataclass.html">Taichi Dataclass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/meta.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/quant.html">Use quantized data types</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Differentiable</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../differentiable/differentiable_programming.html">Differentiable Programming</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Type System</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../type_system/type.html">Type System</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../reference/global_settings.html">Global Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/language_reference.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/operator.html">Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/simt.html">SIMT Intrinsics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/syntax_sugars.html">Syntax Sugars</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../internals/compilation.html">Life of a Taichi Kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internals/internal.html">Internal Designs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">glossary</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../glossary/glossary.html">Glossary</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">FAQs</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../faqs/faq.html">Frequently Asked Questions</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">User guide</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Kernels and Functions</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="kernels-and-functions">
<h1>Kernels and Functions<a class="headerlink" href="#kernels-and-functions" title="Link to this heading">#</a></h1>
<p>Taichi and Python share a similar syntax, but they are not identical. To distinguish Taichi code from native Python code, we utilize three decorators: <code class="docutils literal notranslate"><span class="pre">&#64;ti.kernel</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code>, and <code class="docutils literal notranslate"><span class="pre">&#64;ti.real_func</span></code>:</p>
<ul class="simple">
<li><p>Functions decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.kernel</span></code> are known as <em>Taichi kernels</em> or simply <em>kernels</em>. These functions are the entry points where Taichi’s runtime takes over the tasks, and they <em>must</em> be directly invoked by Python code. You can use native Python to prepare tasks, such as reading data from disk and pre-processing, before calling the kernel to offload computation-intensive tasks to Taichi.</p></li>
<li><p>Functions decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;ti.real_func</span></code> are known as <em>Taichi functions</em>. These functions are building blocks of kernels and can only be invoked by another Taichi function or a kernel. Like normal Python functions, you can divide your tasks into multiple Taichi functions to enhance readability and reuse them across different kernels.</p>
<ul>
<li><p>Taichi functions decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code> are <em>Taichi inline functions</em>. These functions are inlined into the kernels that call them. Runtime recursion of Taichi inline functions are not allowed.</p></li>
<li><p>Taichi functions decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.real_func</span></code> are <em>Taichi real functions</em>. These functions are compiled into separate functions (like the device functions in CUDA) and can be called recursively. Taichi real functions are only supported on the LLVM-based backends (CPU and CUDA backends).</p></li>
</ul>
</li>
</ul>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">inv_square()</span></code> is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.func</span></code> and is a Taichi function. <code class="docutils literal notranslate"><span class="pre">partial_sum()</span></code> is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;ti.kernel</span></code> and is a kernel. The former (<code class="docutils literal notranslate"><span class="pre">inv_square()</span></code>) is called by the latter (<code class="docutils literal notranslate"><span class="pre">partial_sum()</span></code>). The arguments and return value in <code class="docutils literal notranslate"><span class="pre">partial_sum()</span></code> are type hinted, while those in the Taichi function <code class="docutils literal notranslate"><span class="pre">inv_square()</span></code> are not.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">taichi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ti</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inv_square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># A Taichi function</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">partial_sum</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>  <span class="c1"># A kernel</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">inv_square</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="n">partial_sum</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>Here comes a significant difference between Python and Taichi - <em>type hinting</em>:</p>
<ul class="simple">
<li><p>Type hinting in Python is recommended, but not compulsory.</p></li>
<li><p>You must type hint each argument and return value of a Taichi kernel.</p></li>
</ul>
<section id="taichi-scope-and-python-scope">
<h2>Taichi Scope and Python Scope<a class="headerlink" href="#taichi-scope-and-python-scope" title="Link to this heading">#</a></h2>
<p>Let’s introduce two important concepts: <em>Taichi scope</em> and <em>Python scope</em>.</p>
<ul class="simple">
<li><p>The code inside a kernel or a Taichi function is part of the <em>Taichi scope</em>. Taichi’s runtime compiles and executes this code in parallel on multi-core CPU or GPU devices for high-performance computation. The Taichi scope corresponds to the device side in CUDA.</p></li>
<li><p>Code outside of the Taichi scope belongs to the <em>Python scope</em>. The code in the Python scope is written in native Python and executed by Python’s virtual machine, not by Taichi’s runtime. The Python scope corresponds to the host side in CUDA.</p></li>
</ul>
<div class="caution docutils">
<p>Calling a Taichi function in the Python scope results in a syntax error raised by Taichi. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">taichi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ti</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inv_square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">inv_square</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>  <span class="c1"># Syntax error</span>
</pre></div>
</div>
<p>You must call Taichi functions in the Taichi scope.</p>
</div>
<p>It is important to distinguish between kernels and Taichi functions as they have slightly different syntax. The following sections explain their respective usages.</p>
</section>
<section id="kernel">
<h2>Kernel<a class="headerlink" href="#kernel" title="Link to this heading">#</a></h2>
<p>A kernel is the basic unit of execution in Taichi, and it serves as the entry point for Taichi’s runtime which takes over from Python’s virtual machine. Kernels are called in the same way as Python functions, and allow for switching between Taichi’s runtime and Python’s virtual machine.</p>
<p>For instance, the <code class="docutils literal notranslate"><span class="pre">partial_sum()</span></code> kernel can be called inside a Python function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">partial_sum</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">partial_sum</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">partial_sum</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Multiple kernels can be defined in a single Taichi program. These kernels are <em>independent</em> of each other, and are compiled and executed in the same order in which they are <em>first</em> called. The compiled kernels are cached to reduce the launch overhead for subsequent calls.</p>
<div class="caution docutils">
<p>Kernels in Taichi can only be called in the Python scope, and calling a kernel inside another kernel or a Taichi function is not allowed.</p>
</div>
<section id="arguments">
<h3>Arguments<a class="headerlink" href="#arguments" title="Link to this heading">#</a></h3>
<p>A kernel can accept multiple arguments. However, it’s important to note that you can’t pass arbitrary Python objects to a kernel. This is because Python objects can be dynamic and may contain data that the Taichi compiler cannot recognize.</p>
<p>The kernel can accept various argument types, including scalars, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code>. These argument types make it easy to pass data from the Python scope to the Taichi scope. You can find the supported types in the <code class="docutils literal notranslate"><span class="pre">ti.types</span></code> module. For more information on this, see the <a class="reference internal" href="../type_system/type.html"><span class="std std-doc">Type System</span></a>.</p>
<p>Scalars, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code> are passed by value, which means that the kernel receives a copy of the argument. However, <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code> and <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> are passed by reference, which means that any changes made to the argument inside the kernel will affect the original value as well.</p>
<p>Note that we won’t cover <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> here as it is a more advanced topic and is discussed in <a class="reference internal" href="../advanced/meta.html#template-metaprogramming"><span class="std std-ref">Metaprogramming</span></a>.</p>
<p>Here is an example of passing arguments <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> to <code class="docutils literal notranslate"><span class="pre">my_kernel()</span></code> by value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>

<span class="n">my_kernel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Prints 2.0</span>
</pre></div>
</div>
<p>Here is another example of passing a nested struct argument with a matrix to a kernel by value, in which we created a struct type <code class="docutils literal notranslate"><span class="pre">transform_type</span></code> that contains two members: a rotation matrix <code class="docutils literal notranslate"><span class="pre">R</span></code> and a translation vector <code class="docutils literal notranslate"><span class="pre">T</span></code>. We then created another struct type <code class="docutils literal notranslate"><span class="pre">pos_type</span></code> that has <code class="docutils literal notranslate"><span class="pre">transform_type</span></code> as its member and passed an instance of <code class="docutils literal notranslate"><span class="pre">pos_type</span></code> to a kernel.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transform_type</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">mat3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">vec3</span><span class="p">)</span>
<span class="n">pos_type</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">vec3</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="n">transform_type</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kernel_with_nested_struct_arg</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">pos_type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">vec3</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">trans</span><span class="o">.</span><span class="n">R</span> <span class="o">@</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">trans</span><span class="o">.</span><span class="n">T</span>

<span class="n">trans</span> <span class="o">=</span> <span class="n">transform_type</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">mat3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pos_type</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">trans</span><span class="o">=</span><span class="n">trans</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kernel_with_nested_struct_arg</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>  <span class="c1"># [4., 4., 4.]</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code> as a type hint to pass a <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> from NumPy or a <code class="docutils literal notranslate"><span class="pre">tensor</span></code> from PyTorch to a kernel. Taichi recognizes the shape and data type of these data structures, which allows you to access their attributes in a kernel.</p>
<p>In the example below, <code class="docutils literal notranslate"><span class="pre">x</span></code> is updated after <code class="docutils literal notranslate"><span class="pre">my_kernel()</span></code> is called since it is passed by reference:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">taichi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ti</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(),</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ndarray</span><span class="p">()):</span>
    <span class="c1"># Taichi recognizes the shape of the array x and allows you to access it in a kernel</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">my_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints [5, 7, 9]</span>
</pre></div>
</div>
<p>When defining the arguments of a kernel in Taichi, please make sure that each of the arguments has type hint.</p>
<div class="caution docutils">
<p>We have removed the limit on the size of the argument in Taichi v1.7.0.
However, please keep in mind that the size of arguments in a kernel should be small.
When you pass a large argument to a kernel, the compile time will increase significantly.
If you find yourself passing a large argument to a kernel, you may want to consider using a <code class="docutils literal notranslate"><span class="pre">ti.field()</span></code> or a <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code> instead.</p>
<p>We have not tested arguments with a very large size (&gt;4KB), and we do not guarantee that it will work properly.</p>
</div>
</section>
<section id="return-value">
<h3>Return value<a class="headerlink" href="#return-value" title="Link to this heading">#</a></h3>
<p>In Taichi, a kernel can have multiple return values, and the return values can either be a scalar, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, or <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>.
Moreover, in the LLVM-based backends (CPU and CUDA backends), a return value can also be a <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>.</p>
<p>Here is an example of a kernel that returns a struct:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s0</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">vec3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i16</span><span class="p">)</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">s0</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">s1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">s0</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">vec3</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">foo</span><span class="p">())</span>  <span class="c1"># {&#39;a&#39;: 1.0, &#39;b&#39;: {&#39;a&#39;: [100.0, 0.2, 3.0], &#39;b&#39;: 1}}</span>
</pre></div>
</div>
<p>Here is an example of a kernel that returns an integer and a float:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">return_tuple</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>  <span class="c1"># The return type can also be typing.Tuple[ti.i32, ti.f32] or tuple[ti.i32, ti.f32]</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">return_tuple</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># 1 2.0</span>
</pre></div>
</div>
<p>When defining the return value of a kernel in Taichi, it is important to follow these rules:</p>
<ul class="simple">
<li><p>Use type hint to specify the return value of a kernel.</p></li>
<li><p>Make sure that you have at most one return statement in a kernel.</p></li>
</ul>
<div class="caution docutils">
<p>We have removed the limit on the size of the return values in Taichi v1.7.0.
However, please keep in mind that the size of return values in a kernel should be small.
When the return value of the kernel is very large, the compile time will increase significantly.
If you find your return value is very large, you may want to consider using a <code class="docutils literal notranslate"><span class="pre">ti.field()</span></code> or a <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code> instead.</p>
<p>We have not tested return values with a very large size (&gt;4KB), and we do not guarantee that it will work properly.</p>
</div>
<section id="automatic-type-cast">
<h4>Automatic type cast<a class="headerlink" href="#automatic-type-cast" title="Link to this heading">#</a></h4>
<p>In the following code snippet, the return value is automatically cast into the hinted type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_kernel</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">:</span>  <span class="c1"># int32</span>
    <span class="k">return</span> <span class="mf">128.32</span>
<span class="c1"># The return value is cast into the hinted type ti.i32</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_kernel</span><span class="p">())</span>  <span class="c1"># 128</span>
</pre></div>
</div>
</section>
<section id="at-most-one-return-statement">
<h4>At most one return statement<a class="headerlink" href="#at-most-one-return-statement" title="Link to this heading">#</a></h4>
<p>In this code snippet, Taichi raises an error because the kernel <code class="docutils literal notranslate"><span class="pre">test_sign()</span></code> has more than one return statement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_sign</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="c1"># Error: multiple return statements</span>
</pre></div>
</div>
<p>As a workaround, you can save the result in a local variable and return it at the end:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_sign</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">sign</span>
    <span class="c1"># One return statement works fine</span>
</pre></div>
</div>
</section>
</section>
<section id="global-variables-are-compile-time-constants">
<h3>Global variables are compile-time constants<a class="headerlink" href="#global-variables-are-compile-time-constants" title="Link to this heading">#</a></h3>
<p>In Taichi, a kernel treats global variables as compile-time constants. This means that it takes in the current values of the global variables at the time it is compiled and does not track changes to them afterwards. Consider the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">taichi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ti</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kernel_1</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kernel_2</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">kernel_1</span><span class="p">()</span>  <span class="c1"># Prints 1</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">kernel_1</span><span class="p">()</span>  <span class="c1"># Prints 1</span>
<span class="n">kernel_2</span><span class="p">()</span>  <span class="c1"># Prints 2</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">kernel_1</span></code> and <code class="docutils literal notranslate"><span class="pre">kernel_2</span></code> both access the global variable <code class="docutils literal notranslate"><span class="pre">a</span></code>. The first call to <code class="docutils literal notranslate"><span class="pre">kernel_1</span></code> prints 1, which is the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> at the time the kernel was compiled. When <code class="docutils literal notranslate"><span class="pre">a</span></code> is updated to 2, the second call to <code class="docutils literal notranslate"><span class="pre">kernel_1</span></code> still prints 1 because the kernel does not track changes to a after it is compiled.</p>
<p>On the other hand, <code class="docutils literal notranslate"><span class="pre">kernel_2</span></code> is compiled after <code class="docutils literal notranslate"><span class="pre">a</span></code> is updated, so it takes in the current value of <code class="docutils literal notranslate"><span class="pre">a</span></code> and prints 2.</p>
</section>
</section>
<section id="taichi-inline-function">
<h2>Taichi inline function<a class="headerlink" href="#taichi-inline-function" title="Link to this heading">#</a></h2>
<div class="caution docutils">
<p>All Taichi inline functions are force-inlined. This means that if you call a Taichi function from another Taichi function, the callee is fully expanded (inlined) into the caller at compile time. This process continues until there are no more function calls to inline, resulting in a single, large function. This means that runtime recursion of Taichi inline function is <em>not allowed</em>, because it would cause an infinite expansion of the function call stack at compile time. If you want to use runtime recursion, please use Taichi real functions instead.</p>
</div>
<section id="id1">
<h3>Arguments<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>A Taichi inline function can accept multiple arguments, which may include scalar, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.field()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> types.
Note that unlike Taichi kernels, it is not strictly required to type hint the function arguments (but it is still recommended).</p>
</section>
<section id="return-values">
<h3>Return values<a class="headerlink" href="#return-values" title="Link to this heading">#</a></h3>
<p>Return values of a Taichi inline function can be scalars, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>, or other types. Note the following:</p>
<ul class="simple">
<li><p>It is <em>not</em> required (but recommended) to type hint the return values of a Taichi function.</p></li>
<li><p>A Taichi function <em>cannot</em> have more than one <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</p></li>
</ul>
</section>
</section>
<section id="taichi-real-function">
<h2>Taichi real function<a class="headerlink" href="#taichi-real-function" title="Link to this heading">#</a></h2>
<p>Taichi real functions are Taichi functions that are compiled into separate functions (like the device functions in CUDA) and can be called recursively at runtime.
The code inside the Taichi real function are executed serially, which means that you cannot write parallel loop inside it.
However, if the real function is called inside a parallel loop, the real function will be executed in parallel along with other parts of the parallel loop.</p>
<p>If you want to do deep runtime recursion on CUDA, you may need to increase the stack size by passing <code class="docutils literal notranslate"><span class="pre">cuda_stack_limit</span></code> to <code class="docutils literal notranslate"><span class="pre">ti.init()</span></code>.</p>
<p>Taichi real functions are only supported on the LLVM-based backends (CPU and CUDA backends).</p>
<section id="id2">
<h3>Arguments<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<p>A Taichi real function can accept multiple arguments, which may include scalar, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.field()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> types.
The scalar, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code> arguments are passed by value, while the <code class="docutils literal notranslate"><span class="pre">ti.types.ndarray()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.field()</span></code>, and <code class="docutils literal notranslate"><span class="pre">ti.template()</span></code> arguments are passed by reference.</p>
<p>Note that you must type hint the function arguments.</p>
<section id="passing-a-scalar-by-reference">
<h4>Passing a scalar by reference<a class="headerlink" href="#passing-a-scalar-by-reference" title="Link to this heading">#</a></h4>
<p>The Taichi real function also supports passing a scalar by reference. To do this, you need to wrap the type hint with <code class="docutils literal notranslate"><span class="pre">ti.ref()</span></code>.</p>
<p>Here is an example of passing an integer by reference:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@ti</span><span class="o">.</span><span class="n">real_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_one</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)):</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">add_one</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">foo</span><span class="p">()</span>  <span class="c1"># Prints 2</span>
</pre></div>
</div>
<div class="caution docutils">
<p>Passing scalars by reference may be buggy on NVIDIA GPUs with Pascal or older architecture (for example GTX 1080 Ti).
We recommend using the latest NVIDIA GPUs (at least 20-series) if you want to pass a scalar by reference.</p>
</div>
</section>
</section>
<section id="id3">
<h3>Return values<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p>Return values of a Taichi real function can be scalars, <code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code>, <code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>, or other types. Note the following:</p>
<ul class="simple">
<li><p>You must type hint the return values of a Taichi real function.</p></li>
<li><p>A Taichi real function <em>can</em> have more than one <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</p></li>
</ul>
<p>The example below calls the real function <code class="docutils literal notranslate"><span class="pre">sum_func</span></code> recursively to calculate the sum of <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span></code>.
Inside the real function, there are two <code class="docutils literal notranslate"><span class="pre">return</span></code> statements, and the recursion depth is not a constant number.
The cuda stack limit is set to 32kB to allow deep runtime recursion.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cuda</span><span class="p">,</span> <span class="n">cuda_stack_limit</span><span class="o">=</span><span class="mi">32768</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">real_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_func</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">sum_func</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">sum_func</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>  <span class="c1"># 5050</span>
</pre></div>
</div>
<p>You can find more examples of the real function in the <a class="reference external" href="https://github.com/taichi-dev/taichi/tree/master/python/taichi/examples/real_func">repository</a>.</p>
</section>
</section>
<section id="a-recap-taichi-kernel-vs-taichi-inline-function-vs-taichi-real-function">
<h2>A recap: Taichi kernel vs. Taichi inline function vs. Taichi real function<a class="headerlink" href="#a-recap-taichi-kernel-vs-taichi-inline-function-vs-taichi-real-function" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p><strong>Kernel</strong></p></th>
<th class="head"><p><strong>Taichi Function</strong></p></th>
<th class="head"><p>** Taichi Real Function**</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Call scope</p></td>
<td><p>Python scope</p></td>
<td><p>Taichi scope</p></td>
<td><p>Taichi scope</p></td>
</tr>
<tr class="row-odd"><td><p>Type hint arguments</p></td>
<td><p>Mandatory</p></td>
<td><p>Recommended</p></td>
<td><p>Mandatory</p></td>
</tr>
<tr class="row-even"><td><p>Type hint return values</p></td>
<td><p>Mandatory</p></td>
<td><p>Recommended</p></td>
<td><p>Mandatory</p></td>
</tr>
<tr class="row-odd"><td><p>Return type</p></td>
<td><p><ul><li>Scalar</li><li><code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code>(Only on LLVM-based backends)</li></ul></p></td>
<td><p><ul><li>Scalar</li><li><code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code></li><li>…</li></ul></p></td>
<td><p><ul><li>Scalar</li><li><code class="docutils literal notranslate"><span class="pre">ti.types.matrix()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.vector()</span></code></li><li><code class="docutils literal notranslate"><span class="pre">ti.types.struct()</span></code></li><li>…</li></ul></p></td>
</tr>
<tr class="row-even"><td><p>Maximum number of return statements</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>Unlimited</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="key-terms">
<h2>Key terms<a class="headerlink" href="#key-terms" title="Link to this heading">#</a></h2>
<section id="backend">
<h3>Backend<a class="headerlink" href="#backend" title="Link to this heading">#</a></h3>
<p>In the computer world, the term <em>backend</em> may have different meanings based on the context, and generally refers to any part of a software program that users do not directly engage with. In the context of Taichi, backend is the place where your code is being executed, for example <code class="docutils literal notranslate"><span class="pre">cpu</span></code>, <code class="docutils literal notranslate"><span class="pre">opengl</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda</span></code>, and <code class="docutils literal notranslate"><span class="pre">vulkan</span></code>.</p>
</section>
<section id="compile-time-recursion">
<h3>Compile-time recursion<a class="headerlink" href="#compile-time-recursion" title="Link to this heading">#</a></h3>
<p>Compile-time recursion is a technique of meta-programming. The recursion is handled by Taichi’s compiler and expanded and compiled into a serial function without recursion. The recursion conditions must be constant during compile time, and the depth of the recursion must be a constant.</p>
</section>
<section id="force-inline">
<h3>Force inline<a class="headerlink" href="#force-inline" title="Link to this heading">#</a></h3>
<p>Force inline means that the users cannot choose whether to inline a function or not. The function will always be expanded into the caller by the compiler.</p>
</section>
<section id="metaprogramming">
<h3>Metaprogramming<a class="headerlink" href="#metaprogramming" title="Link to this heading">#</a></h3>
<p>Metaprogramming generally refers to the manipulation of programs with programs. In the context of Taichi, it means generating actual-running programs with compile-time computations. In many cases, this allows developers to minimize the number of code lines to express a solution.</p>
</section>
<section id="runtime-recursion">
<h3>Runtime recursion<a class="headerlink" href="#runtime-recursion" title="Link to this heading">#</a></h3>
<p>Runtime recursion is the kind of recursion that happens at runtime. The compiler does not expand the recursion, and it is compiled into a function that calls itself recursively. The recursion conditions are evaluated at runtime, and the depth does not need to be a constant number.</p>
</section>
<section id="type-hint">
<h3>Type hint<a class="headerlink" href="#type-hint" title="Link to this heading">#</a></h3>
<p>Type hinting is a formal solution to statically indicate the type of value within your code.</p>
</section>
</section>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Link to this heading">#</a></h2>
<section id="can-i-call-a-kernel-inside-a-taichi-function">
<h3>Can I call a kernel inside a Taichi function?<a class="headerlink" href="#can-i-call-a-kernel-inside-a-taichi-function" title="Link to this heading">#</a></h3>
<p>No. Keep in mind that a kernel is the smallest unit for Taichi’s runtime execution. You cannot call a kernel inside a Taichi function (in the Taichi scope). You can <em>only</em> call a kernel in the Python scope.</p>
</section>
<section id="can-i-specify-different-backends-for-each-kernel-separately">
<h3>Can I specify different backends for each kernel separately?<a class="headerlink" href="#can-i-specify-different-backends-for-each-kernel-separately" title="Link to this heading">#</a></h3>
<p>Currently, Taichi does not support using multiple different backends simultaneously. Specifically, at any given time, Taichi only uses one backend. While you can call <code class="docutils literal notranslate"><span class="pre">ti.init()</span></code> multiple times in a program to switch between the backends, after each <code class="docutils literal notranslate"><span class="pre">ti.init()</span></code> call, all kernels will be recompiled to the new backend. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>

<span class="n">test</span><span class="p">()</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">gpu</span><span class="p">)</span>

<span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>In the provided code, we begin by designating the CPU as the backend, upon which the <code class="docutils literal notranslate"><span class="pre">test</span></code> function operates. Notably, the <code class="docutils literal notranslate"><span class="pre">test</span></code> function is initially executed on the CPU backend. As we proceed by invoking <code class="docutils literal notranslate"><span class="pre">ti.init(arch=ti.gpu)</span></code> to designate the GPU as the backend, all ensuing invocations of <code class="docutils literal notranslate"><span class="pre">test</span></code> trigger a recompilation of the <code class="docutils literal notranslate"><span class="pre">test</span></code> kernel tailored for the GPU backend, subsequently executing on the GPU. To conclude, Taichi does not facilitate the concurrent operation of multiple kernels on varied backends.</p>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../basic/sparse.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Spatially Sparse Data Structures</p>
      </div>
    </a>
    <a class="right-next"
       href="kernel_sync.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Synchronization between Kernels and Python Scope</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#taichi-scope-and-python-scope">Taichi Scope and Python Scope</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel">Kernel</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#arguments">Arguments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#return-value">Return value</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#automatic-type-cast">Automatic type cast</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#at-most-one-return-statement">At most one return statement</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#global-variables-are-compile-time-constants">Global variables are compile-time constants</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#taichi-inline-function">Taichi inline function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Arguments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#return-values">Return values</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#taichi-real-function">Taichi real function</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Arguments</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#passing-a-scalar-by-reference">Passing a scalar by reference</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">Return values</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-recap-taichi-kernel-vs-taichi-inline-function-vs-taichi-real-function">A recap: Taichi kernel vs. Taichi inline function vs. Taichi real function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#key-terms">Key terms</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#backend">Backend</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compile-time-recursion">Compile-time recursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#force-inline">Force inline</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metaprogramming">Metaprogramming</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runtime-recursion">Runtime recursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#type-hint">Type hint</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#faq">FAQ</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#can-i-call-a-kernel-inside-a-taichi-function">Can I call a kernel inside a Taichi function?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#can-i-specify-different-backends-for-each-kernel-separately">Can I specify different backends for each kernel separately?</a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/user_guide/kernels/kernel_function.md.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2023 Taichi Graphics Inc; 2025 Genesis AI Inc.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>